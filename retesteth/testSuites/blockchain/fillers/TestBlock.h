#pragma once
#include <testStructures/structures.h>

typedef std::vector<BlockHeader> vectorOfSchemeBlock;
class TestBlock
{
public:
    // Successfully mined block
    TestBlock(BlockHeader const& _header, string const& _chainName, FORK const& _chainNet, VALUE const& _number,
        string const& _expectException, bool _doNotExport = false)
      : m_chainName(_chainName), m_expectException(_expectException), m_doNotExport(_doNotExport)
    {
        m_blockNumber = spVALUE(new VALUE(_number));
        m_chainNet = spFORK(new FORK(_chainNet));
        m_block = spEthereumBlock(new EthereumBlock(_header));
    }

    // Raw block RLP, that cann not be generated by retesteth
    TestBlock(BYTES const& _rlp, string const& _chainName, FORK const& _chainNet, VALUE const& _number,
        string const& _expectException, bool _doNotExport = false)
      : m_chainName(_chainName), m_expectException(_expectException), m_doNotExport(_doNotExport)
    {
        m_blockNumber = spVALUE(new VALUE(_number));
        m_chainNet = spFORK(new FORK(_chainNet));
        m_rawRLP = spBYTES(new BYTES(_rlp));
    }

    bool isDoNotExport() const { return m_doNotExport; }
    EthereumBlock const& ethBlock() const { return m_block.getCContent(); }

    // Attach uncle header of potential fork to this block
    // If test has no uncles this will not be called
    void setNextBlockForked(BlockHeader const& _next) { m_nextBlockForked = spBlockHeader(new BlockHeader(_next)); }
    BlockHeader const& getNextBlockForked() const { return m_nextBlockForked.getCContent(); }

    BYTES const getRLP() const
    {
        if (!m_block.isEmpty())
            return m_block.getCContent().getRLP();
        return m_rawRLP.getCContent();
    }

    // Attach Uncle header to EthereumBlock (the one described in tests)
    void addUncle(BlockHeader const& _uncle) { m_block.getContent().addUncle(_uncle); }
    std::vector<BlockHeader> const& getUncles() const { return m_block.getCContent().uncles(); }

    // Attach Transaction header to EthereumBlock (the one described in tests)
    void addTransaction(Transaction const& _tr) { m_block.getContent().addTransaction(_tr); }

    // Attach actual RLP of a block that been imported
    void addActualRLP(BYTES const& _rlp) { m_actualRLP = spBYTES(new BYTES(_rlp)); }


    DataObject asDataObject() const
    {
        DataObject res;
        res["chainname"] = m_chainName;
        // res["chainnetwork"] = m_chainNet.getCContent().asString();
        res["blocknumber"] = m_blockNumber.getCContent().asString();
        if (!m_expectException.empty())
            res["expectException"] = m_expectException;

        if (m_rawRLP.isEmpty())
        {
            res["uncleHeaders"] = DataObject(DataType::Array);
            for (auto const& un : m_block.getCContent().uncles())
                res["uncleHeaders"].addArrayObject(un.asDataObject());
            res["blockHeader"] = m_block.getCContent().header().asDataObject();
            res["transactions"] = DataObject(DataType::Array);
            for (auto const& tr : m_block.getCContent().transactions())
                res["transactions"].addArrayObject(tr.asDataObject());
            res["rlp"] = m_actualRLP.getCContent().asString();
        }
        else
            res["rlp"] = m_rawRLP.getCContent().asString();

        return res;
    }

private:
    TestBlock() {}
    spEthereumBlock m_block;
    string m_chainName;
    spFORK m_chainNet;
    string m_expectException;
    spVALUE m_blockNumber;
    spBYTES m_rawRLP;
    spBYTES m_actualRLP;
    bool m_doNotExport;

    // A block mined in paralel representing an uncle (it has the same blocknumber)
    spBlockHeader m_nextBlockForked;  // Hypothetical next block for uncles
};
